'use strict';

/*
  Объекты и массивы в JS мутабельны (мы можем их изменять: добавлять в них элементы, удалять, модифицировать).
  Но это чревато ошибками при невнимательном использовании.

  Например, если мы хотим создать копию нашего массива и присвоим новой переменной значение, которое хранит первая переменная,
  то на самом деле скопируется не массив, а ссылка на него и, если мы модифицируем массив по второй переменной, то изменится и исходный массив.
 */

const array = [1, 2, 3];

let array2 = array;
array2.push(4);

console.log('array2: ' + array2 + ', array: ' + array); // array2: 1,2,3,4, array: 1,2,3,4

/*
  Ключевая особенность функционального программирования — неизменяемость.
  Как же примирить врожденную изменяемость JS при написании функционального JS?
  Существуют библиотеки, поддерживающие неизменяемость в JS.
  Mori предоставляет постоянные структуры данных на основе Clojure.
  Immutable.js от Facebook также предоставляет неизменяемые коллекции для JS.
  Библиотеки утилит, такие как Underscore.js и lodash, предоставляют методы и модули
  для более функционального стиля программирования (а стало быть направленного на неизменяемость).

  В целом, JavaScript — язык с сильной изменяемостью. Некоторые стили JS-кодирования опираются на эту врожденную изменяемость.
  Однако, при написании функционального JS, реализация неизменяемости требует внимательности.
  Если вы что-то нечаянно модифицируете, JS не будет выбрасывать ошибки.
  Тестирование и библиотеки могут помочь, но работа с неизменяемостью в JS требует практики и методологии.
  Неизменяемость имеет свои преимущества. В результате получается код, который проще понимать.
  Он также обеспечивает персистентность, возможность хранения более старых версий структур данных и копирование только изменившихся частей.
  Недостатком неизменяемости является то, что многие алгоритмы и операции не могут быть эффективно реализованы.
 */

// Если мы хотим создать копию существующего массива для её дальнейшей модификации, но при этом оставить исходный массив нетронутым
// и, кроме того, не задействовать дополнительную память для хранения копии исходного массива до модификации,
// можно использовать специальные методы:

// спред оператор - оператор расширения, позволяет расширять выражения в тех местах,
// где предусмотрено использование нескольких аргументов (при вызовах функции) или ожидается несколько элементов (для массивов).
const array3 = [...array2, 5];

console.log('array2: ' + array2 + ', array3: ' + array3); // array2: 1,2,3,4, array3: 1,2,3,4,5

// или метод slice(begin, end), который копирует участок массива от begin до end, не включая end.
const array4 = array3.slice(0);
array4.push(6);

console.log('array3: ' + array3 + ', array4: ' + array4); // array3: 1,2,3,4, array4: 1,2,3,4,5,6
